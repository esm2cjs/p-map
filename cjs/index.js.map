{
  "version": 3,
  "sources": ["../esm/index.js"],
  "sourcesContent": ["import AggregateError from '@esm2cjs/aggregate-error';\n\n/**\nAn error to be thrown when the request is aborted by AbortController.\nDOMException is thrown instead of this Error when DOMException is available.\n*/\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\n/**\nTODO: Remove AbortError and just throw DOMException when targeting Node 18.\n*/\nconst getDOMException = errorMessage => globalThis.DOMException === undefined\n\t? new AbortError(errorMessage)\n\t: new DOMException(errorMessage);\n\n/**\nTODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\n*/\nconst getAbortedReason = signal => {\n\tconst reason = signal.reason === undefined\n\t\t? getDOMException('This operation was aborted.')\n\t\t: signal.reason;\n\n\treturn reason instanceof Error ? reason : getDOMException(reason);\n};\n\nexport default async function pMap(\n\titerable,\n\tmapper,\n\t{\n\t\tconcurrency = Number.POSITIVE_INFINITY,\n\t\tstopOnError = true,\n\t\tsignal,\n\t} = {},\n) {\n\treturn new Promise((resolve, reject_) => {\n\t\tif (iterable[Symbol.iterator] === undefined && iterable[Symbol.asyncIterator] === undefined) {\n\t\t\tthrow new TypeError(`Expected \\`input\\` to be either an \\`Iterable\\` or \\`AsyncIterable\\`, got (${typeof iterable})`);\n\t\t}\n\n\t\tif (typeof mapper !== 'function') {\n\t\t\tthrow new TypeError('Mapper function is required');\n\t\t}\n\n\t\tif (!((Number.isSafeInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency >= 1)) {\n\t\t\tthrow new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t\t}\n\n\t\tconst result = [];\n\t\tconst errors = [];\n\t\tconst skippedIndexesMap = new Map();\n\t\tlet isRejected = false;\n\t\tlet isResolved = false;\n\t\tlet isIterableDone = false;\n\t\tlet resolvingCount = 0;\n\t\tlet currentIndex = 0;\n\t\tconst iterator = iterable[Symbol.iterator] === undefined ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();\n\n\t\tconst reject = reason => {\n\t\t\tisRejected = true;\n\t\t\tisResolved = true;\n\t\t\treject_(reason);\n\t\t};\n\n\t\tif (signal) {\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t}\n\n\t\t\tsignal.addEventListener('abort', () => {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t});\n\t\t}\n\n\t\tconst next = async () => {\n\t\t\tif (isResolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst nextItem = await iterator.next();\n\n\t\t\tconst index = currentIndex;\n\t\t\tcurrentIndex++;\n\n\t\t\t// Note: `iterator.next()` can be called many times in parallel.\n\t\t\t// This can cause multiple calls to this `next()` function to\n\t\t\t// receive a `nextItem` with `done === true`.\n\t\t\t// The shutdown logic that rejects/resolves must be protected\n\t\t\t// so it runs only one time as the `skippedIndex` logic is\n\t\t\t// non-idempotent.\n\t\t\tif (nextItem.done) {\n\t\t\t\tisIterableDone = true;\n\n\t\t\t\tif (resolvingCount === 0 && !isResolved) {\n\t\t\t\t\tif (!stopOnError && errors.length > 0) {\n\t\t\t\t\t\treject(new AggregateError(errors));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tisResolved = true;\n\n\t\t\t\t\tif (skippedIndexesMap.size === 0) {\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst pureResult = [];\n\n\t\t\t\t\t// Support multiple `pMapSkip`'s.\n\t\t\t\t\tfor (const [index, value] of result.entries()) {\n\t\t\t\t\t\tif (skippedIndexesMap.get(index) === pMapSkip) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpureResult.push(value);\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(pureResult);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolvingCount++;\n\n\t\t\t// Intentionally detached\n\t\t\t(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst element = await nextItem.value;\n\n\t\t\t\t\tif (isResolved) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst value = await mapper(element, index);\n\n\t\t\t\t\t// Use Map to stage the index of the element.\n\t\t\t\t\tif (value === pMapSkip) {\n\t\t\t\t\t\tskippedIndexesMap.set(index, value);\n\t\t\t\t\t}\n\n\t\t\t\t\tresult[index] = value;\n\n\t\t\t\t\tresolvingCount--;\n\t\t\t\t\tawait next();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (stopOnError) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrors.push(error);\n\t\t\t\t\t\tresolvingCount--;\n\n\t\t\t\t\t\t// In that case we can't really continue regardless of `stopOnError` state\n\t\t\t\t\t\t// since an iterable is likely to continue throwing after it throws once.\n\t\t\t\t\t\t// If we continue calling `next()` indefinitely we will likely end up\n\t\t\t\t\t\t// in an infinite loop of failed iteration.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait next();\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\t\t};\n\n\t\t// Create the concurrent runners in a detached (non-awaited)\n\t\t// promise. We need this so we can await the `next()` calls\n\t\t// to stop creating runners before hitting the concurrency limit\n\t\t// if the iterable has already been marked as done.\n\t\t// NOTE: We *must* do this for async iterators otherwise we'll spin up\n\t\t// infinite `next()` calls by default and never start the event loop.\n\t\t(async () => {\n\t\t\tfor (let index = 0; index < concurrency; index++) {\n\t\t\t\ttry {\n\t\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\t\tawait next();\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (isIterableDone || isRejected) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t})();\n\t});\n}\n\nexport const pMapSkip = Symbol('skip');\n"],
  "mappings": "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",
  "names": ["AggregateError", "index", "error"]
}
